#' @importFrom rlang .data
NULL

#' Create nodes for a step-package Sankey diagram
#'
#' @param x A data frame containing at least a `package` column where each
#'   entry describes the package combination at a given step.
#'
#' @return A data frame with columns `name`, `node_name`, and `id` suitable for
#'   use with [networkD3::sankeyNetwork()].
#'
#' @examples
#' df <- simulate(3)
#' make_nodes(df)
#'
#' @export
make_nodes <- function(x) {
  stopifnot("package" %in% names(x))

  nodes <- data.frame(
    name = sort(unique(x$package)),
    stringsAsFactors = FALSE
  )

  nodes$node_name <- vapply(
    nodes$name,
    function(value) gsub(", ", "\n", value, fixed = TRUE),
    character(1)
  )

  nodes$id <- as.character(seq_len(nrow(nodes)) - 1L)

  nodes
}

#' Build link definitions between Sankey nodes
#'
#' @param x A data frame containing at least `id`, `step`, and `package`
#'   columns describing package transitions for each simulation run.
#' @param nodes Optional nodes data frame as returned by [make_nodes()]. If
#'   omitted the nodes are derived from `x`.
#'
#' @return A tibble describing links between nodes including `source`,
#'   `target`, and tooltip metadata.
#'
#' @export
make_links <- function(x, nodes = make_nodes(x)) {
  required_cols <- c("id", "step", "package")
  missing <- setdiff(required_cols, names(x))
  if (length(missing) > 0) {
    stop("`x` must contain columns: ", paste(missing, collapse = ", "))
  }

  if (!"name" %in% names(nodes)) {
    stop("`nodes` must contain a `name` column.")
  }

  node_lookup <- nodes$name

  x |>
    dplyr::arrange(.data$id, .data$step) |>
    dplyr::group_by(.data$id) |>
    dplyr::mutate(
      next_package = dplyr::lead(.data$package),
      next_step = dplyr::lead(.data$step)
    ) |>
    dplyr::ungroup() |>
    dplyr::group_by(dplyr::across(c(.data$package, .data$next_package, .data$step))) |>
    dplyr::summarise(value = dplyr::n(), .groups = "drop") |>
    dplyr::mutate(
      source = match(.data$package, node_lookup) - 1L,
      target = match(.data$next_package, node_lookup) - 1L,
      label = gsub(", ", "\n", .data$package, fixed = TRUE),
      id = as.character(.data$source)
    ) |>
    dplyr::mutate(
      change = purrr::map2_chr(
        strsplit(.data$package, ",\\s*"),
        strsplit(.data$next_package, ",\\s*"),
        ~ {
          if (any(is.na(.y))) {
            return(NA_character_)
          }
          new <- setdiff(.y, .x)
          paste(new, collapse = ", ")
        }
      )
    ) |>
    dplyr::mutate(
      tooltip = paste0("\u2192: add ", .data$change, "\n\u2190: remove ", .data$change)
    ) |>
    as.data.frame()
}

#' Create a D3 colour scale for Sankey nodes
#'
#' @param id Character vector of node identifiers, usually from
#'   `nodes$id`.
#'
#' @return A JavaScript expression defining a D3 ordinal scale that maps nodes
#'   to pastel colours.
#' @export
make_colours <- function(id) {
  pal <- c(
    "#AEC6CF", # pastel blue
    "#FFB347", # pastel orange
    "#77DD77", # pastel green
    "#FF6961", # pastel red/coral
    "#CBAACB", # pastel lilac
    "#F49AC2", # pastel pink
    "#FFD1DC", # very pale rose
    "#B5EAD7", # pastel mint
    "#FFFACD", # pastel lemon
    "#ADD8E6", # soft sky blue
    "#E0BBE4", # pastel lavender
    "#F7CAC9", # blush pink
    "#BFD8B8"  # pastel sage green
  )

  # Build a D3 ordinal scale string
  colourScale <- sprintf(
    'd3.scaleOrdinal().domain(%s).range(%s)',
    jsonlite::toJSON(id, auto_unbox = TRUE),
    jsonlite::toJSON(pal[seq_along(id)], auto_unbox = TRUE)
  )

  return(colourScale)
}

#' Render a step-package Sankey diagram
#'
#' @param nodes Data frame describing Sankey nodes as produced by
#'   [make_nodes()].
#' @param links Data frame describing connections between nodes, typically the
#'   output of [make_links()].
#' @param colours JavaScript colour scale generated by [make_colours()].
#' @param font_size Node label font size in pixels.
#' @param link_alpha Default opacity applied to all links when
#'   `value_scaled_alpha` is `FALSE`.
#' @param value_scaled_alpha Should link opacity be scaled according to its
#'   value?
#' @param alpha_range Numeric range to use when scaling link opacity by value.
#' @param node_width Width of each node rectangle in pixels. Use `NULL` to keep
#'   the networkD3 default.
#' @param split_newlines Should newline characters in labels be converted into
#'   stacked `<tspan>` elements for readability?
#' @param center_labels Should text labels be horizontally centred on each
#'   node?
#' @param place_labels_above When `TRUE`, nudges labels above the node
#'   rectangle.
#' @param label_y_offset Vertical offset (in pixels) used when moving labels
#'   above the node.
#'
#' @return An htmlwidgets object produced by
#'   [networkD3::sankeyNetwork()].
#' @export
make_sankey <- function(
    nodes,
    links,
    colours,
    node_width = 30,
    font_size = 14,                 # px -> passed to sankeyNetwork(fontSize=)
    link_alpha = 0.35,              # 0..1 (used if value_scaled_alpha = FALSE)
    value_scaled_alpha = FALSE,     # if TRUE, alpha scaled by link value
    alpha_range = c(0.2, 0.8),      # used when value_scaled_alpha = TRUE
    split_newlines = TRUE,          # turn '\n' in labels into stacked <tspan> lines
    center_labels = TRUE,           # horizontally centre labels on each node
    place_labels_above = FALSE,     # if TRUE, nudge text above node
    label_y_offset = -6,            # px shift when placing above
    sinks_right = TRUE,              # passed to sankeyNetwork(sinksRight=)
    width = 1200,
    height = 700
) {
  stopifnot(length(alpha_range) == 2)

  # Use the exact same filtered order for both the widget and the tooltips we attach
  links_filtered <- dplyr::filter(links, !is.na(.data$next_package))

  sn <- networkD3::sankeyNetwork(
    Links       = links_filtered,
    Nodes       = nodes,
    Source      = "source",
    Target      = "target",
    Value       = "value",
    NodeID      = "node_name",
    NodeGroup   = "id",
    LinkGroup   = "id",
    units       = "",
    colourScale = colours,
    fontSize    = font_size,
    nodeWidth   = node_width,
    sinksRight = sinks_right,
    height = height,
    width = width
  )

  # Expose tooltips to JS (parallel to Links order)
  if (!is.null(links_filtered$tooltip)) {
    sn$x$links$tooltip <- links_filtered$tooltip
  }

  js_bool <- function(x) if (isTRUE(x)) "true" else "false"

  js <- sprintf('
function(el, x) {

  function applyLineBreaks(sel) {
    if (!%s) return;
    sel.each(function(){
      var self = d3.select(this);
      var text = self.text();
      if (text && text.indexOf("\\n") > -1) {
        var lines = text.split("\\n");
        self.text(null);
        for (var i = 0; i < lines.length; i++) {
          self.append("tspan")
              .text(lines[i])
              .attr("x", null)
              .attr("dy", i === 0 ? 0 : "1.2em");
        }
      }
    });
  }

  function recenterLabels() {
    var firstRect = d3.select(el).select(".node rect");
    if (firstRect.empty()) return;
    var nodeWidth = +firstRect.attr("width") || 24;

    var texts = d3.select(el).selectAll(".node text");

    if (%s) {
      texts.attr("text-anchor", "middle")
           .attr("x", nodeWidth / 2);
      d3.select(el).selectAll(".node text tspan")
           .attr("x", nodeWidth / 2);
    }

    if (%s) {
      texts.attr("y", %d);
    }
  }

  function setLinkOpacity() {
    var links = d3.select(el).selectAll(".link");

    if (%s) {
      var vals = (x.links || []).map(function(d){ return +d.value; }).filter(isFinite);
      if (vals.length) {
        var min = Math.min.apply(null, vals), max = Math.max.apply(null, vals);
        if (min === max) {
          links.style("stroke-opacity", %f);
        } else {
          var lin = (d3.scaleLinear || d3.scale.linear);
          var op  = lin().domain([min, max]).range([%f, %f]);
          links.style("stroke-opacity", function(d){ return op(+d.value); });
        }
      }
    } else {
      links.style("stroke-opacity", %f);
    }
  }

  function setTooltips() {
    var linkSel = d3.select(el).selectAll(".link");
    var tooltips = (x && x.links) ? x.links.map(function(l){ return l.tooltip; }) : null;

    linkSel.select("title").remove();
    linkSel.append("title")
      .text(function(d,i){
        if (typeof d.tooltip !== "undefined" && d.tooltip !== null) return d.tooltip;
        if (tooltips && tooltips[i]) return tooltips[i];
        var fmt = (d3.format ? d3.format(",.0f") : function(x){return x;});
        var src = d.source && d.source.name ? d.source.name : "";
        var tgt = d.target && d.target.name ? d.target.name : "";
        return src + " \\u2192 " + tgt + "\\n" + fmt(+d.value);
      });
  }

  // First pass
  var texts = d3.select(el).selectAll(".node text");
  applyLineBreaks(texts);
  recenterLabels();
  setLinkOpacity();
  setTooltips();

  // Second pass after layout to resist widget re-positioning
  requestAnimationFrame(function(){
    recenterLabels();
    setLinkOpacity();
    setTooltips();
  });
}
',
js_bool(split_newlines),
js_bool(center_labels),
js_bool(place_labels_above), as.integer(label_y_offset),
js_bool(value_scaled_alpha),
as.numeric(link_alpha),
as.numeric(alpha_range[1]), as.numeric(alpha_range[2]),
as.numeric(link_alpha)
  )

  htmlwidgets::onRender(sn, js)
}
